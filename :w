module VoorbeeldModule where

import Numeric (readFloat, readHex, readSigned)
import Text.ParserCombinators.Parsec
import System.Exit (exitFailure)
import System.IO

parse :: String -> IO [GameObjectField]
parse fileName = parseFromFile pText fileName >>= either report return
  where report err = exitFailure

main :: IO ()
main = do
     result <- parseFromFile pText "levels/test1.txt"
     case result of
       Left err     -> print err
       Right output -> print output

data GameObjectField = Id String 
                | X Int
                | Y Int
                | Name String
                | Description String     
                | UseTimes UseTime
                | ObjectValue Int
                | GameActions [GameAction]
                deriving (Eq, Show)

data UseTime = Finite Int | Infinite deriving (Eq, Show)

type Name = String
type GameId = String
data Arguments = Function GameFunction | GameIds [GameId]
    deriving (Eq, Show)

-- TODO Record syntax?
data GameFunction = GameFuntion Name Arguments 
    deriving (Eq, Show)

type Conditions = [GameFunction]
type Action = GameFunction
data GameAction = GameAction Conditions Action 
    deriving (Eq, Show)

pGameObjectField :: CharParser () GameObjectField
pGameObjectField = value <* spaces
    where value = Id          <$> pField "id" pString
              <|> X           <$> pField "x" pNumber
              <|> Y           <$> pField "y" pNumber
              <|> Name        <$> pField "name" pString
              <|> Description <$> pField "description" pString
              <|> UseTimes    <$> pField "useTimes" pUseTime
              <|> ObjectValue <$> pField "value" pNumber
              <|> GameActions  <$> pField "actions" pGameActions
              <?> "GameObjectField"

pGameActions :: CharParser  () [GameAction]
pGameActions = pObjectOf pGameAction

pGameAction :: CharParser () GameAction
pGameAction = GameAction <$> pListOf pGameFunction <*> (spaces *> pGameFunction)

pGameFunction :: CharParser () GameFunction
pGameFunction = GameFuntion <$> pFunctionName <*> pFunctionArguments <* char ')')

pFunctionName :: CharParser () String
pFunctionName = pCharsButNot ",(]" <* char '(' 

pFunctionArguments :: CharParser () Arguments
pFunctionArguments = (GameIds <$> pGameIds) <|> (Function <$> pGameFunction) 

pGameIds :: CharParser () [String]
pGameIds = pSingleGameId `sepBy` char ',' 

pSingleGameId :: CharParser () String
pSingleGameId  = spaces *> pCharsButNot [',', ')', ' ', '('] <* spaces

pCharsButNot :: [Char] -> CharParser () String
pCharsButNot excluded = many1 $ satisfy (`notElem` excluded)

-- JSON tekst bestaat uit ofwel een object ofwel een array, met eventueel whitespace
pText :: CharParser () [GameObjectField] 
pText = spaces *> pObjectOf pGameObjectField

pField :: String -> CharParser () a -> CharParser () a
pField key valueParser = (string key >> char ':' >> spaces) >> valueParser

pString :: CharParser () String
pString = between (char '\"') (char '\"') (pCharsButNot ['"'])

pUseTime :: CharParser () UseTime
pUseTime = (Infinite <$ string "infinite") <|> (Finite <$> pNumber)

readInt :: String -> Int
readInt = read

pNumber :: CharParser () Int
pNumber = readInt <$> many1 digit

pListOf, pObjectOf, pTupleOf :: CharParser () a -> CharParser () [a]
pListOf   = pSeries '[' ']'
pObjectOf = pSeries '{' '}'
pTupleOf  = pSeries '(' ')'

pSeries :: Char -> Char -> CharParser () a  -> CharParser () [a]
pSeries left right parser = between (char left <* spaces) (char right) $
                        (parser <* spaces) `sepBy` (char ',' <* spaces)
